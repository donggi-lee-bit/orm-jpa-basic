# 프록시

em.find()가 아닌 em.getReference() 를 통해 가져온 객체를 확인해보면 텅텅 비어있는 객체를 가져온다. <br>
이는 프록시를 이용해 가짜 객체를 생성한 것이다. <br>
<br>
프록시는 실제 클래스를 상속 받아서 만들어진다. 겉모습은 실제 클래스와 같으며 이론 상으로 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용할 수 있다.

## 프록시 특징

프록시 객체는 실제 객체의 참조를 보관합니다. <br>
프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드를 호출합니다. <br>

## 프록시 객체의 초기화

클라이언트가 프록시 객체의 메서드를 호출한다. <br>
프록시 객체는 실제로 아무것도 저장하고 있지 않지만 `JPA`가 `영속성 컨텍스트`에 실제 엔티티 초기화하기를 요청한다. <br>
영속성 컨텍스트는 DB를 통해 실제 엔티티를 가져와서 반환하게된다. <br>
그리하여 프록시 내부의 멤버변수 target에 실제 엔티티 저장하고 해당 엔티티를 볼 수 있게된다. <br>

## **프록시의 특징**

프록시 객체는 처음 사용할 때 한 번만 초기화됩니다. 여러 번 요청해도 처음 한 번만 초기화되고 그 뒤로 초기화되지 않습니다. 프록시 객체를 초기화할 때 프록시 객체가 실제 엔티티로 바뀌는 게 아닙니다. 초기화를 하면 프록시 객체를 통해 실제 엔티티에 접근 가능하게 되는 것입니다. 

프록시 객체는 원본 엔티티를 상속 받습니다. 따라서 프록시 객체의 타입 체크시 `==` 비교는 실패하게 되고, `instanceof`를 사용하여 타입을 체크해야합니다. `JPA` 에서 엔티티 타입을 비교할 때는 되도록이면 `==` 비교 대신 `instanceof`를 사용하도록 합니다. 프록시 객체를 쓸지도 모르니까요.

영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `getReference()` 로 엔티티를 호출해도 실제 엔티티를 반환합니다.

영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때 프록시를 초기화하면 문제가 발생하게 됩니다.
`org.hibernate.LazyInitializationException`

## 프록시 확인

프록시 인스턴스 초기화 여부 확인
- PersistenceUnitUtil.isLoaded(Object entity)

프록시 클래스 확인 방법
- entity.getClass().getName() 출력

프록시 강제 초기화
- org.hibernate.Hibernate.initialize(entity)

# 즉시 로딩과 지연 로딩



# 지연 로딩 활용

# 영속성 전이

# 고아 객체

# 영속성 전이와 고아 객체, 생명주기
